<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>offensive_security on Rem &#39;s Blog</title>
    <link>https://fumerem.github.io/tags/offensive_security/</link>
    <description>Recent content in offensive_security on Rem &#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 12 Jun 2022 17:15:54 +0800</lastBuildDate><atom:link href="https://fumerem.github.io/tags/offensive_security/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>rust编写shellcode加载器</title>
      <link>https://fumerem.github.io/posts/rust/rust%E7%BC%96%E5%86%99shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/</link>
      <pubDate>Sun, 12 Jun 2022 17:15:54 +0800</pubDate>
      
      <guid>https://fumerem.github.io/posts/rust/rust%E7%BC%96%E5%86%99shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/</guid>
      <description>​	突发奇想用rust写一个shellcode加载器,花了两天研究了思路和大佬的代码.
项目地址:https://github.com/fumerem/shellcode_loader
0x00 shellcode加载器原理 shellcode:一段16进制的机器码,后渗透中经常使用它来得到shell而得名.
加载器原理:为shellcode分配动态内存,并创建进程执行shellcode
0x01 加载器的编写 先列举一下加载器需要调用的windows的api
VistualAlloc 申请内存
LPVOID VirtualAlloc { LPVOID lpAddress, #要分配的内存区域的地址 DWORD dwSize, #分配的大小 DWORD flAllocationType, #分配的类型 DWORD flProtect #该内存的初始保护属性 };
代码实现
unsafe { memory.ptr = Memory::VirtualAlloc( ptr::null(), //memory address to distribute len, //memory size Memory::MEM_COMMIT | Memory::MEM_RESERVE, //alloc type Memory::PAGE_EXECUTE_READWRITE, //protect attribute ) as *mut u8; }; CreateThread 创建进程调用CreateThread将在主线程的基础上创建一个新线程CreateThread
HANDLE CreateThread ( LPSECURITY_ATTRIBUTES lpThreadAttributes,#线程安全属性 SIZE_T dwStackSize, #置初始栈的大小，以字节为单位 LPTHREAD_START_ROUTINE lpStartAddress, #指向线程函数的指针 LPVOID lpParameter, #向线程函数传递的参数 DWORD dwCreationFlags, #线程创建属性 LPDWORD lpThreadId #保存新线程的id )</description>
    </item>
    
  </channel>
</rss>
