# 从底层了解rust的所有权机制



rust有一处特殊的地方，所有权。

## 0x00 C++和rust的区别

先看c++

```c++
#include <iostream>
using namespace std;
int main() {
    string str1 = "hello";
    string str2 = str1;
    cout << str1 << str2;
}
```

声明字符串str1，将str1的值赋值给str2，然后打印str1，str2，编译没有问题。


再看rust

```rust
fn main() {
	let a = String::from("hello");
 	let b = a;
    println!("{} {}", a, b)
}
```

编译一下

![](https://s2.loli.net/2022/04/04/7cdVm3u4oHSJ15e.png)

好的，报错了，怎么回事呢。a的所有权已经移交给b，所以无法借用a。

那么rust为什么要这么设计，不麻烦吗？

## 0x01 为什么设计所有权

​	当今计算机内存栈和堆的分配机制，决定了编程语言中的值主要分两类：值类型（Value）和引用类型（Reference）。

> ​	**值类型：数据直接存储在栈中的数据类型**，比如数值，布尔值，结构体。因为在栈中，操作效率比较高。值类型作为右值执行赋值时，会自动复制一个新副本。
>
> ​	**引用类型：数据存储在堆中，栈中储存值的地址（指针）**，比如数组，字符串。操作效率一般比较低。像java，python等语言用GC回收，c，c++等系统语言须程序员手动回收。

​	随着编程语言的发展，类型越来愈丰富，值类型和引用类型已无法完美描述类型。比如Vector容器类型，内部可以包含数值类型，也可以包含引用类型，它怎么分类？

​	之后便引出了：**值语义**（Value Semantic）和**引用语义**（Reference Semantic）

> ​	**值语义**：按位复制后，与原始对象无关
>
> ​	**引用语义**：也称指针语义。一般指数据存放堆上，通过栈上的指针来管理堆中数据，并且引用语义禁止按位复制

​	值语义保证了数据的独立性，如果想修改一个值，只能通过修改它自身来修改，无法通过修改它的复制品来修改。而引用语义禁止按位复制，因为按位复制只能复制栈上的指针，存放在堆的数值同时存在两个指针对它管理，影响内存安全。

```rust
fn main() {
    let x = 100;
    let y = x;
    assert_eq!(x, 100);
    assert_eq!(y, 100);
}
```

​	x为整型，它作为右值赋值给y，编译器默认调用x的clone进行按位复制。复制完成后，y和x互相独立，互不影响。整型实现了Copy trait，其clone方法必须是按位复制的，不会对原数据造成破坏，不存在内存安全的问题。而C++，如果开发者疏忽，就可能存在内存安全问题。

```rust
#[derive(Copy, Clone)]
struct A {
    a: i32,
    b: Box<i32>,
}
fn main() {}
```

![](https://s2.loli.net/2022/04/04/BoIPuUwkVOrFEpq.png)

​	智能指针Box<T>是典型的引用类型，无法实现Copy，禁止实现按位复制（可以使用clone显式复制进行深调用）。

## 0x02 所有权机制

​	rust使用Copy Trait来区分值语义和引用语义，同时使用引入新语义：**复制（Copy）和移动（Move）**，保证内存安全和性能。

​	对于可以安全地在栈上按位复制的类型，只需按位复制。对于堆上的类型，无法安全地在栈上按位复制，若想保证内存安全，只能深复制（在栈上重新开辟内存，带来性能开销）。若堆上数据不变，只在栈上移动指针位置，那就同时实现了内存安全和高性能。

```rust
fn main() {
	let x = Box::new(100);
	let y = x;
	assert_eq!(y, 100);
    //println!("{}", x) ERROR!!!
}
```

​	以上，没有发生按位移动，只是将x的指针指向了y，杜绝了堆上同一值存在两个指针的情况，保证了内存安全。起初x对Box<T>拥有所有权，之后x的所有权转移给了y，最终由y释放Box<T>的堆内存。

​	**一个值的所有权被转移给另外一个变量绑定的过程，称为所有权转移。**

​	Rust中每个值都有一个所有者，更进一步说就是，Rust中分配的每块内存都有其所有者，所有者负责该内存的释放和读写权限，并且每次每个值只能有唯一的所有者。这就是 Rust的**所有权机制（OwnerShip）**。

